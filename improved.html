<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <title>Phoria - Dev test page 2</title>
      <script src="scripts/gl-matrix.js"></script>
      <script src="scripts/phoria-util.js"></script>
      <script src="scripts/phoria-entity.js"></script>
      <script src="scripts/phoria-scene.js"></script>
      <script src="scripts/phoria-renderer.js"></script>
<script src="scripts/phoria-view.js"></script>
      <script src='scripts/dat.gui.min.js'></script>
      <script>
var requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame || window.msRequestAnimationFrame || 
                       function(c) {window.setTimeout(c, 15)};
/**
   Phoria
   pho·ri·a (fôr-)
   n. The relative directions of the eyes during binocular fixation on a given object
*/
// bind to window onload event
window.addEventListener('load', onloadHandler, false);
function onloadHandler()
{
   Phoria.Util.importGeometryWavefront({
      url: "Girl+Head.obj",
      scaleTo: 3,
      fnSuccess: generateScene,
      reorder: false,
      center: true
   });
}
function generateScene(obj)
{
   // get the canvas DOM element and the 2D drawing context
   var canvas = document.getElementById('canvas');
   
   // create the scene and setup camera, perspective and viewport
   var scene = new Phoria.Scene();
   scene.camera.position = {x:0.0, y:3.0, z:-15.0};
   scene.perspective.aspect = canvas.width / canvas.height;
   scene.viewport.width = canvas.width;
   scene.viewport.height = canvas.height;
   
   // create a canvas renderer
   var renderer = new Phoria.CanvasRenderer(canvas);
   
   // GENERATE TEST ENTITIES
   // add a grid to help visualise camera position etc.
   var plane = Phoria.Util.generateTesselatedPlane(16,16,0,20);
   scene.graph.push(Phoria.Entity.create({
      points: plane.points,
      edges: plane.edges,
      polygons: plane.polygons,
      style: {
         drawmode: "wireframe",
         shademode: "plain",
         linewidth: 0.5,
         objectsortmode: "back"
      }
   }));
   var teapot = Phoria.Entity.create({
      points: obj.points,
      polygons: obj.polygons,
      style: {
         specular: 0,
opacity:0.2,
         drawmode: "solid",
         shademode: "lightsource",   //gouraud
         fillmode: "filltwice"
      }
   });
   teapot.translateZ(1);
  // teapot.translateY(-14);
   teapot.translateX(-1);
   teapot.scaleN(3);
var t;
t=teapot.points.length;
console.log(t);
    var i;
var j;
for(i=0;i<800;i++){
teapot.polygons[i].opacity=0.001;
}
/*for(j=4500;j<5000;j++){
teapot.polygons[j].opacity=0.001;
}
/*for(i=(teapot.points.length)/2;i<(teapot.points.length)/1;i++){
teapot.polygons[i].color=[0,1,0];
}
//i=teapot.points[0].x;
/*for(j=0;j<teapot.points.length;j++){
if(i<teapot.points[j].x){i=teapot.points[j].x;}
}
console.log(i);*/
    /*for(i=0;i<=300;i++){
j=teapot.points[i].x;
    teapot.points[i].x=j+3;
//teapot.points[i].y=teapot.points[i].y+0;
//teapot.points[i].z=teapot.points[i].z+0.3;
}*/
  /* for(i=0;i<teapot.polygons.length;i++){
console.log("{vertices:[",teapot.polygons[i].vertices[0],",",teapot.polygons[i].vertices[1],",",teapot.polygons[i].vertices[2],"]},        ");
}*/
   //teapot.points[10].x=100;
   scene.graph.push(teapot);
   // add a light
   scene.graph.push(Phoria.DistantLight.create({
      color: [0.5,0.5,1.0],
      intensity: 0.10,
      direction: {x:0, y:-1, z:1}
   }));
   var visibleLightObj = Phoria.Entity.create({
      points: [{x:-2, y:4, z:-6}],
      style: {
         //color: "#bfbfbf",
         drawmode: "point",
         shademode: "plain",
         linewidth: 5,
         linescale: 2
      }
   });
   scene.graph.push(visibleLightObj);
   var light = Phoria.PointLight.create({
      color: [1,1,0],
      position: {x:-2, y:4, z:-6},
      intensity: 0.3,
      attenuation: 0.03
   });
   visibleLightObj.children.push(light);


/*var rotateZ3D = function(theta) {
    var sinTheta = tan(theta);
    var cosTheta = cos(theta);
    
    for (var n=0; n<teapot.points.length; n++) {
        var node = teapot.points[n];
        var x = node[0];
        var y = node[1];
        node[0] = x * cosTheta - y * sinTheta;
        node[1] = y * cosTheta + x * sinTheta;
    }
};*/

//rotateZ3D(30);


//var ctx = teapot.getContext("3d");
//ctx.rotate(20 * Math.PI / 180);
//ctx.fillRect(50, 20, 100, 50);

/*var Vector3;
       gameObj.transform.eulerAngles = new Vector3(
        gameObj.transform.eulerAngles.x,
        gameObj.transform.eulerAngles.y + 180,
        gameObj.transform.eulerAngles.z
    );*/

   var mohit=document.getElementById("stop");
	mohit.onclick=function(){
	var t;
		for(t=0;t<400;t++){
		teapot.polygons[t].opacity=0.001;
		}
	}

   // keep track of rotation
   var mouse = Phoria.View.addMouseEvents(canvas);
   var rot = {
      x: 5, y: 5, z: 0,
      velx: 0, vely: 0, velz: 0,
      nowx: 0, nowy: 0, nowz: 0,
      ratio: 0.1
   };

   var pause = false;
   var fnAnimate = function() {
      if (!pause)
      {
         // rotate local matrix of the cube
         rot.nowy += (rot.vely = (mouse.velocityV - rot.y - rot.nowy) * rot.ratio);
         rot.nowx += (rot.velx = (rot.x - rot.nowx) * rot.ratio);
         rot.nowz += (rot.velz = (mouse.velocityH - rot.z - rot.nowz) * rot.ratio);
         
         teapot.rotateY(-rot.vely*Phoria.RADIANS).rotateX(-rot.velx*Phoria.RADIANS).rotateZ(-rot.velz*Phoria.RADIANS);

         // execute the model view 3D pipeline and render the scene
         scene.modelView();
         renderer.render(scene);
      }
      requestAnimFrame(fnAnimate);
   };

//teapot.rotation.x = Math.PI / 180 * 90;
   /*var pause = false;
   var fnAnimate = function() {
      if (!pause)
      {
         // rotate local matrix of an object
         teapot.rotateY(2.5*Phoria.RADIANS);
         // the light position is edited directly via the GUI - update the visible indicator
         visibleLightObj.points[0].x = light.position.x;
         visibleLightObj.points[0].y = light.position.y;
         visibleLightObj.points[0].z = light.position.z;
         // execute the model view 3D pipeline
         scene.modelView();
         // and render the scene
         renderer.render(scene);
      }
      
      requestAnimFrame(fnAnimate);
   };*/
   
   // add GUI controls
   var gui = new dat.GUI();
   var f = gui.addFolder('Perspective');
   f.add(scene.perspective, "fov").min(5).max(175);
   f.add(scene.perspective, "near").min(1).max(100);
   f.add(scene.perspective, "far").min(1).max(1000);
   //f.open();
   f = gui.addFolder('Camera LookAt');
   f.add(scene.camera.lookat, "x").min(-100).max(100);
   f.add(scene.camera.lookat, "y").min(-100).max(100);
   f.add(scene.camera.lookat, "z").min(-100).max(100);
   //f.open();
   f = gui.addFolder('Camera Position');
   f.add(scene.camera.position, "x").min(-100).max(100);
   f.add(scene.camera.position, "y").min(-100).max(100);
   f.add(scene.camera.position, "z").min(-100).max(100);
   //f.open();
   f = gui.addFolder('Camera Up');
   f.add(scene.camera.up, "x").min(-10).max(10).step(0.1);
   f.add(scene.camera.up, "y").min(-10).max(10).step(0.1);
   f.add(scene.camera.up, "z").min(-10).max(10).step(0.1);
   f = gui.addFolder('Rendering');
   f.add(teapot.style, "shademode", ["plain", "lightsource"]);
   f.add(teapot.style, "doublesided");
   f = gui.addFolder('Light');
   f.add(light.position, "x").min(-25).max(25).step(0.1);
   f.add(light.position, "y").min(-25).max(25).step(0.1);
   f.add(light.position, "z").min(-25).max(25).step(0.1);
   f.add(light.color, "0").min(0).max(1).step(0.1).name("red");
   f.add(light.color, "1").min(0).max(1).step(0.1).name("green");
   f.add(light.color, "2").min(0).max(1).step(0.1).name("blue");
   f.add(light, "intensity").min(0).max(1).step(0.1);
   f.add(light, "attenuation").min(0.01).max(0.25).step(0.01);
   //f.open();
   // key binding
   document.addEventListener('keydown', function(e) {
      switch (e.keyCode)
      {
         case 27:
         {
            pause = !pause;
            break;
         }
      }
   }, false);
   
   // start animation
   requestAnimFrame(fnAnimate);
}
 </script>

   </head>

   <body style="background-color: #bfbfbf">
      <canvas id="canvas" width="768" height="512" style="background-color: #bfbfbf"></canvas>
      <div><a style="color:#225588;text-decoration:none;" href="./index.html">&lt;&lt; </a></div>
		<input type="radio" name="labial" id="stop" value="spread" checked=true >&nbsp;stop<br>

   </body>
</html>


